# Process Injection // DLL Injection

## Useful Links

[WinAPI](https://learn.microsoft.com/en-us/windows/win32/apiindex/windows-api-list)

## Mini-projects

- dllinjection.c

#### [dllinjection.c](./dllinjection.c)

> mingw32-g++.exe -shared -o dllinjection.dll dllscript.c   

Essentially create a DLL (basic DllMain to open a MessageBox when attached to a process), allocate memory within a specifided process, write the DLL location to process memory, get the address in Kernel32 where LoadLibrary() happens, create a remote thread with start address = where LoadLibrary() happens, pass the allocated memory (which is now our DLL location) as a variable and done!

## Notes

Common API Calls:
> [ShellCode API Calls](../Shellcode%20Injection/notes.md)

> [GetModuleHandleA()](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulehandlea)

> [GetProcAddress()](https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress)

> [LoadLibraryA()](https://learn.microsoft.com/en-us/windows/win32/api/https://learn.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya?redirectedfrom=MSDN/nf-processthreadsapi-openprocess)

> [DllMain()](https://learn.microsoft.com/en-us/windows/win32/dlls/dllmain)

Caveats:

> "The major downside to LoadLibraryA() is that it registers the loaded DLL with the program and thus can be easily detected. Another slightly annoying caveat is that if a DLL has already been loaded once with LoadLibraryA(), it will not execute it. You can work around this issue but it's more code." - Brad Antoniewicz, Open Security Research
